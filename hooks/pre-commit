#!/usr/bin/env python
# -*-python-*-

# Please to be reading this before you start making changes here:
# https://github.com/whosonfirst/git-whosonfirst-data#caveats

import os
import sys
import logging

import sys
import re
import subprocess

import pkg_resources
import requests

import StringIO

import mapzen.whosonfirst.validator
import mapzen.whosonfirst.export
import mapzen.whosonfirst.utils
import mapzen.whosonfirst.diff

logging.basicConfig(level=logging.INFO)

if __name__ == '__main__':

   try:
      out = subprocess.check_output(["git", "log", "-1", "HEAD"])
      out = out.splitlines()
   
      ignore, hash = out[0].split(" ")

      logging.info("invoking git-whosonfirst-mapzen pre-commit hooks for %s" % hash)
   except Exception, e:
      logging.warning("failed to determined git hash, because %s" % e)

   # Some basic sanity checking to ensure that people are running the most recent
   # version of the py-mz-wof libraries (20160127/thisisaaronland)

   pymz = pkg_resources.get_distribution("mapzen.whosonfirst").version
   pymz = pymz.rstrip("-")

   current = None

   try:
      logging.info("I am going to try and see whether you are using the most recent version of py-mapzen-whosonfirst...")

      rsp = requests.get("https://raw.githubusercontent.com/whosonfirst/py-mapzen-whosonfirst/master/VERSION")
      current = rsp.content
      current = current.strip()

   except Exception, e:
      logging.warning("Failed to determine ACTUAL current version of py-mapzen-whosonfirst, because %s (setting current to %s for now but don't be surprised if HILARITY ensues...)" % (e, pymz))
      current = pymz

   if pymz != current:
      logging.warning("You are running version %s of py-mapzen-whosonfirst but the current version is %s - you should update because HILARITY may ensue if you don't" % (pymz, current))

   # who's on first... har har har... sad trombone
   
   whoami = sys.argv[0]
   whoami = os.path.abspath(whoami)

   hooks = os.path.dirname(whoami)
   dotgit = os.path.dirname(hooks)
   root = os.path.dirname(dotgit)

   data = os.path.join(root, "data")
   meta = os.path.join(root, "meta")

   # sudo put me in a function

   modified = re.compile('^[MA]\s+(?P<name>.*)$')

   out = subprocess.check_output(["git", "status", "--porcelain"])
   files = []

   for line in out.splitlines():

      match = modified.match(line)

      if match:

         fname = match.group('name')
         parsed = mapzen.whosonfirst.utils.parse_filename(fname)

         if not parsed:
            continue

         id, suffix = parsed

         if suffix:
            logging.info("%s has a suffix (%s) so skipping" % (fname, suffix))
            continue
            
         files.append(fname)
      
   # end sudo put me in a function

   if len(files) == 0:
      logging.info("nothing in this commit that we need to apply pre-commit hooks to")
      sys.exit(0)

   vld = mapzen.whosonfirst.validator.validator()

   exporter = mapzen.whosonfirst.export.flatfile(data)
   updated = []

   recommit = []

   for rel_path in files:

      abs_path = os.path.join(root, rel_path)
      logging.info("validating %s" % abs_path)

      rpt = vld.validate_file(abs_path)

      if not rpt.ok():

         logging.error("%s FAILED validation test" % abs_path)

         # sudo make the following less bad...
         # (20151111/thisisaaronland)

         fh = StringIO.StringIO()
         rpt.print_report(fh)
         fh.seek(0)

         logging.error("validation report is:\n%s" % "".join(fh.readlines()))
         sys.exit(1)

      # disabling this for now since it has a habit of being a lot of unnecessary
      # cycles - there is much to value in the stuff below but it's not clear how
      # to know when and when not to trigger it... (20151123/thisisaaronland)

      """
      logging.info("formatting and exportifying %s" % abs_path)

      # actually export the file - this will do formatting, ensure various properties
      # are set and assign the lastmodified time

      feature = mapzen.whosonfirst.utils.load_file(abs_path)
      exporter.export_feature(feature)

      # append the absolute path to a list of things to reference when rebuilding the
      # meta files; append the relative path to a list of things to reference when
      # updating the commit so that changes to the individual records and meta files
      # are included; this is some serious git-magic rain-dancing happenind here so
      # please to ensure that it never escapes this file (20151112/thisisaaronland)
      """

      updated.append(abs_path)
      recommit.append(rel_path)

   # these are used to extend 'modified' and 'created' below

   modified = []
   created = []

   # meta files

   # these are the meta files (including the -latest.csv pointers) that need to be made relative
   # in order to dance with the git commit

   # ensure relative paths to files in the meta files

   meta_kwargs = {
      'paths': 'relative',
      'prefix': data,
   }

   _modified, _created = mapzen.whosonfirst.utils.update_placetype_metafiles(meta, updated, **meta_kwargs)

   for path in _modified:
      path = path.replace(root + "/", "")
      modified.append(path)

   for path in _created:
      path = path.replace(root + "/", "")
      created.append(path)

   # Concordances - IMPORTANT: per the caveats in the 'update_concordances_metafile'
   # method we are still not pruning files in updated for only those with actual
   # updates (to their concordances). This is being done with the mapzen.whosonfirst.diff
   # library. We will probably move this up the stack (in this workflow) at some point
   # but for today it lives here... (20160122/thisisaaronland)

   diff = mapzen.whosonfirst.diff.compare(source=root)
   updated_concordances = []

   for path in updated:

      path = os.path.abspath(path)
      id, ignore = mapzen.whosonfirst.utils.parse_filename(path)

      try:
         report = diff.report(id)
         logging.info("change report for %s: %s" % (path, report))

         if report['concordances'] == True:
            updated_concordances.append(path)
      except Exception, e:
         logging.warning("failed to generate report for %s, because %s" % (path, e))

   logging.info("count updated: %d count updated w/ updated concordances: %d" % (len(updated), len(updated_concordances)))

   if updated_concordances:
      concordances = meta			# this will change (20160119/thisisaaronland)
      concordances_kwargs = meta_kwargs		# these probably won't change but giving them a bespoke name anyway

      _modified, _created = mapzen.whosonfirst.utils.update_concordances_metafile(concordances, updated_concordances, **concordances_kwargs)

      for path in _modified:
         path = path.replace(root + "/", "")
         modified.append(path)

      for path in _created:
         path = path.replace(root + "/", "")
         created.append(path)

   # phew!

   recommit.extend(modified)
   recommit.extend(created)

   # this is the part where we write the modified files to disk to be picked up by the
   # post-commit hook because trying to add them to the git index here results in one
   # face-stabby git error after another (take your pick) - if someone knows how to do
   # this (add/append the newly modified files to the current commit) at this stage I 
   # would love to hear about it. (20151112/thisisaaronland)

   # see also:
   # https://stackoverflow.com/questions/3284292/can-a-git-hook-automatically-add-files-to-the-commit

   if len(recommit):

      dotcommit = os.path.join(root, ".commit")
      logging.info("writing %s to disk to be processed by the post-commit hook" % dotcommit)

      fh = open(dotcommit, "w")
      fh.write("\n".join(recommit))
      fh.close()

   sys.exit(0)
