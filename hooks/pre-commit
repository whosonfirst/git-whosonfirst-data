#!/usr/bin/env python
# -*-python-*-

import os
import sys
import logging

import sys
import re
import subprocess

import StringIO

import mapzen.whosonfirst.validator
import mapzen.whosonfirst.export
import mapzen.whosonfirst.utils

logging.basicConfig(level=logging.INFO)

if __name__ == '__main__':

   logging.info("invoking git-whosonfirst-mapzen pre-commit hooks")

   # who's on first... har har har... sad trombone
   
   whoami = sys.argv[0]
   whoami = os.path.abspath(whoami)

   hooks = os.path.dirname(whoami)
   dotgit = os.path.dirname(hooks)
   root = os.path.dirname(dotgit)

   data = os.path.join(root, "data")
   meta = os.path.join(root, "meta")

   # sudo put me in a function

   modified = re.compile('^[MA]\s+(?P<name>.*)$')

   out = subprocess.check_output(["git", "status", "--porcelain"])
   files = []

   for line in out.splitlines():

      match = modified.match(line)

      if match:

         fname = match.group('name')
         
         # account for alt files here... how?
         # also sudo put this logic in a function

         if fname.endswith(".geojson"):
            files.append(fname)
      
   # end sudo put me in a function

   if len(files) == 0:
      sys.exit(0)

   # who am I? this is relevant if we need to amend the commit
   # below

   out = subprocess.check_output(["git", "log", "-1", "HEAD"])
   out = out.splitlines()
   
   ignore, hash = out[0].split(" ")
   logging.info("processing commit hash %s" % hash)

   vld = mapzen.whosonfirst.validator.validator()

   exporter = mapzen.whosonfirst.export.flatfile(data)
   updated = []

   recommit = []

   for rel_path in files:

      abs_path = os.path.join(root, rel_path)
      logging.info("validating %s" % abs_path)

      rpt = vld.validate_file(abs_path)

      if not rpt.ok():

         logging.error("%s FAILED validation test" % abs_path)

         # sudo make the following less bad...
         # (20151111/thisisaaronland)

         fh = StringIO.StringIO()
         rpt.print_report(fh)
         fh.seek(0)

         logging.error("validation report is:\n%s" % "".join(fh.readlines()))

         sys.exit(1)

      logging.info("formatting and exportifying %s" % abs_path)

      # actually export the file - this will do formatting, ensure various properties
      # are set and assign the lastmodified time

      feature = mapzen.whosonfirst.utils.load_file(abs_path)
      exporter.export_feature(feature)

      # append the absolute path to a list of things to reference when rebuilding the
      # meta files; append the relative path to a list of things to reference when
      # updating the commit so that changes to the individual records and meta files
      # are included; this is some serious git-magic rain-dancing happenind here so
      # please to ensure that it never escapes this file (20151112/thisisaaronland)

      updated.append(abs_path)
      recommit.append(rel_path)

   # this is the part where we update / append the commit 
   # note: this is not working or rather appears to be working but spewing errors like this:
   # fatal: cannot lock ref 'HEAD': ref refs/heads/master is at d5481aa574bd322da0408473449c058e9e3210aa but expected 450206eeca8df3ec594f4e7b2a43f70dc7356842

   # see also:
   # https://stackoverflow.com/questions/3284292/can-a-git-hook-automatically-add-files-to-the-commit
   
   _modified, _created = mapzen.whosonfirst.utils.update_placetype_metafiles(meta, updated)

   modified = []
   created = []

   # these are the meta files (including the -latest.csv pointers) that need to be made relative
   # in order to dance with the git commit

   for path in _modified:
      path = path.replace(root + "/", "")
      modified.append(path)

   for path in _created:
      path = path.replace(root + "/", "")
      created.append(path)

   recommit.extend(modified)
   recommit.extend(created)

   logging.info("files modified during pre-commit %s" % ";".join(recommit))

   if len(created):
      cmd = ["git", "add"]
      cmd.extend(created)

      logging.info(" ".join(cmd))
      out = subprocess.check_output(cmd)

      logging.info(out)

   # Hey look - see the '--no-verify' flag? That is the important bit that
   # prevents this whole process from spiraling in to a neverending spiral
   # of git pre-commiting itself over and over and over and over and well
   # you get the point (20151112/thisisaaronland)

   # Note that hash is defined up above after we've ensured that there are
   # some files we care about pre-commit-ing

   cmd = ["git", "commit", "--amend", "-C", hash, "--no-verify"]
   cmd.extend(recommit)

   logging.info(" ".join(cmd))
   out = subprocess.check_output(cmd)

   logging.info(out)
   sys.exit(0)
