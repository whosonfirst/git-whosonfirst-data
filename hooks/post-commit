#!/usr/bin/env python
# -*-python-*-

# Please to be reading this before you start making changes here:
# https://github.com/whosonfirst/git-whosonfirst-data#caveats

import os
import sys
import logging

import subprocess

import mapzen.whosonfirst.utils

logging.basicConfig(level=logging.INFO)

if __name__ == '__main__':

   import optparse
   opt_parser = optparse.OptionParser()

   opt_parser.add_option('--commit-hash', dest='commit_hash', action='store', default="HEAD", help='Invoke hooks for a specific commit hash, default is HEAD')
   opt_parser.add_option('-v', '--verbose', dest='verbose', action='store_true', default=False, help='Be chatty (default is false)')
   
   options, args = opt_parser.parse_args()

   if options.verbose:	
      logging.basicConfig(level=logging.DEBUG)
   else:
      logging.basicConfig(level=logging.INFO)

   commit_hash = options.commit_hash

   if commit_hash == "HEAD":

      cmd = ["git", "log", "-1", "HEAD"]
      logging.debug(" ".join(cmd))

      out = subprocess.check_output(cmd)
      out = out.splitlines()
      
      ignore, hash = out[0].split(" ")

   else:
      hash = commit_hash

   logging.info("invoking git-whosonfirst-mapzen post-commit hooks for %s" % hash)

   # I dunno ... still trying to work out how to make this all invoked from
   # a specific commit hash as well as just the default "most recent" work
   # (20160326/thisisaaronland)
   
   if commit_hash != "HEAD":
      logging.warning("commit hash is not HEAD so it's not clear what's going to happen...")

   # who's on first... har har har... sad trombone
   
   whoami = sys.argv[0]
   whoami = os.path.abspath(whoami)

   hooks = os.path.dirname(whoami)
   dotgit = os.path.dirname(hooks)
   root = os.path.dirname(dotgit)

   data = os.path.join(root, "data")
   meta = os.path.join(root, "meta")

   cmd = ["git", "show", "--pretty=format:", "--name-only", commit_hash]
   logging.debug(" ".join(cmd))

   out = subprocess.check_output(cmd)
   files = []

   # see also: notes in pre-commit
   # see also-er: https://stackoverflow.com/questions/3284292/can-a-git-hook-automatically-add-files-to-the-commit

   dotcommit = os.path.join(root, ".commit")

   if os.path.exists(dotcommit):

      logging.info("%s exists, so I am going to look for files that have been modified" % dotcommit)

      to_add = []

      fh = open(dotcommit)

      for rel_path in fh.readlines():

         rel_path = rel_path.strip()
         abs_path = os.path.join(root, rel_path)

         if not os.path.exists(abs_path):
            continue

         to_add.append(rel_path)
      
      fh.close()
      os.unlink(dotcommit)

      if len(to_add):

         cmd = ["git", "add", "meta"]

         # Hey look - see what's happening here? We're only
         # "adding" stuff in the meta directory since that's
         # the only place that (as of this writing) new files
         # should have been created. The alternative is the
         # scenario descibed in issue #3 where I tried to add
         # 90K files on the command-line. The results were
         # entirely predictable in retrospect....
         # (20151117/thisisaaronland)

         # cmd.extend(to_add)
         
         out = subprocess.check_output(cmd)

         logging.info(" ".join(cmd))
         logging.debug(out)

         # note the --no-verify flag  - this is very very very important
         # without it you will send git in to an endless spiral where it
         # invokes the pre-commit hook... which you know maybe is a good
         # interview question (good albeit cruel) but isn't very useful
         # for actually getting any work done... (20151112/thisisaaronland)

         cmd = ["git", "commit", "--amend", "-C", commit_hash, "--no-verify"]
         logging.debug(" ".join(cmd))

         out = subprocess.check_output(cmd)

         logging.info(" ".join(cmd))
         logging.info(out)

   # okay now we're going to see if there are any files we need to modify
   # post-commit... because, you know... post-commit

   for fname in out.splitlines():

      parsed = mapzen.whosonfirst.utils.parse_filename(fname)

      if not parsed:
         continue

      id, suffix = parsed

      if suffix:
         logging.info("%s has a suffix (%s) so skipping" % (fname, suffix))
         continue

      files.append(fname)

   if len(files) == 0:
      logging.info("nothing else in this commit that we need to apply post-commit hooks to")
      sys.exit(0)

   # not a bug - we just haven't defined anything beyond this stage
   # see post-push for hooks to push to S3 etc (20151113/thisisaaronland)

   sys.exit(0)
